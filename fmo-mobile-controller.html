<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>FMO Mobile Controller</title>
    <style>
        :root {
            /* 默认使用 Orange Theme (参考截图) */
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent-cyan: #ff9800;   /* 主橙色 */
            --accent-magenta: #ffb74d; /* 辅助橙色/高亮 */
            --accent-green: #4caf50;
            --border-color: #333333;
            --viz-bg: #1a1a1a;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        /* 设备适配：桌面端/平板端字体放大 */
        :root.device-desktop {
            font-size: 19.2px; /* 16px * 1.2 */
        }

        /* 主题定义 - 保留其他作为可选项 */
        body.theme-cyberpunk {
            --bg-color: #050505;
            --panel-bg: rgba(20, 20, 20, 0.85);
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent-cyan: #00f3ff;
            --accent-magenta: #ff00ff;
            --accent-green: #00ff66;
            --border-color: rgba(255, 255, 255, 0.15);
            --viz-bg: radial-gradient(circle at center, #111 0%, #000 100%);
        }


        /* 主题定义 */
        body.theme-matrix {
            --bg-color: #000000;
            --panel-bg: rgba(0, 20, 0, 0.9);
            --text-main: #00ff00;
            --text-muted: #008800;
            --accent-cyan: #00ff00; /* 主色调 */
            --accent-magenta: #008f11; /* 辅色调 */
            --accent-green: #00ff00;
            --border-color: rgba(0, 255, 0, 0.2);
            --viz-bg: #000;
        }

        body.theme-ocean {
            --bg-color: #001f3f;
            --panel-bg: rgba(0, 31, 63, 0.85);
            --text-main: #b3e5fc;
            --text-muted: #568ea3;
            --accent-cyan: #7FDBFF;
            --accent-magenta: #0074D9;
            --accent-green: #39CCCC;
            --border-color: rgba(127, 219, 255, 0.2);
            --viz-bg: linear-gradient(to bottom, #001f3f, #001020);
        }

        body.theme-sunset {
            --bg-color: #2d1b2e;
            --panel-bg: rgba(45, 27, 46, 0.85);
            --text-main: #ffd1dc;
            --text-muted: #b07289;
            --accent-cyan: #ff9e64;
            --accent-magenta: #ff0055;
            --accent-green: #ffca28;
            --border-color: rgba(255, 158, 100, 0.2);
            --viz-bg: linear-gradient(to bottom, #2d1b2e, #1a0f1a);
        }

        body.theme-light {
            --bg-color: #f0f2f5;
            --panel-bg: rgba(255, 255, 255, 0.9);
            --text-main: #333333;
            --text-muted: #666666;
            --accent-cyan: #2196F3;
            --accent-magenta: #673AB7;
            --accent-green: #4CAF50;
            --border-color: rgba(0, 0, 0, 0.1);
            --viz-bg: #e0e0e0;
        }

        /* 新增主题：猛男粉 */
        body.theme-pink {
            --bg-color: #2e001f;
            --panel-bg: rgba(60, 0, 40, 0.85);
            --text-main: #ffc2d1;
            --text-muted: #d88fa5;
            --accent-cyan: #ff4081;
            --accent-magenta: #f50057;
            --accent-green: #ff80ab;
            --border-color: rgba(255, 64, 129, 0.2);
            --viz-bg: linear-gradient(to bottom, #2e001f, #1a0010);
        }

        /* 新增主题：基佬紫 */
        body.theme-purple {
            --bg-color: #1a002e;
            --panel-bg: rgba(40, 0, 60, 0.85);
            --text-main: #e1bee7;
            --text-muted: #ba68c8;
            --accent-cyan: #d500f9;
            --accent-magenta: #aa00ff;
            --accent-green: #e040fb;
            --border-color: rgba(213, 0, 249, 0.2);
            --viz-bg: linear-gradient(to bottom, #1a002e, #0d0017);
        }

        /* 新增主题：蕾丝红 */
        body.theme-red {
            --bg-color: #2b0000;
            --panel-bg: rgba(50, 0, 0, 0.85);
            --text-main: #ffcdd2;
            --text-muted: #e57373;
            --accent-cyan: #ff1744;
            --accent-magenta: #d50000;
            --accent-green: #ff5252;
            --border-color: rgba(255, 23, 68, 0.2);
            --viz-bg: linear-gradient(to bottom, #2b0000, #150000);
        }

        /* 新增主题：流氓黑 */
        body.theme-black {
            --bg-color: #000000;
            --panel-bg: #111111;
            --text-main: #ffffff;
            --text-muted: #666666;
            --accent-cyan: #ffffff;
            --accent-magenta: #333333;
            --accent-green: #999999;
            --border-color: #333333;
            --viz-bg: #000000;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100dvh; /* 适配移动端视口 */
            display: grid;
            grid-template-rows: auto auto 1fr auto; /* Header, Settings, Viz, Controls */
            grid-template-areas: 
                "header"
                "settings"
                "viz"
                "controls";
            overflow: hidden;
            transition: background-color 0.5s, color 0.5s;
            
            /* Safe Area Adaptation */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            
            overscroll-behavior: none; /* 防止页面整体回弹 */
        }

        /* 按钮触摸优化 */
        button, .btn-rect-lg, .vol-track-wrapper, .station-item {
            touch-action: manipulation;
        }

        /* 顶部状态栏 */
        header {
            grid-area: header;
            padding: 10px 15px; /* 减少 padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            transition: background 0.5s, border-color 0.5s;
            margin: 10px 10px 0 10px;
            border-radius: var(--radius-md);
        }

        .brand {
            font-size: 0.95rem;
            font-weight: bold;
            letter-spacing: 0.5px;
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: normal; /* 允许换行 */
            min-width: 0; /* 允许在 flex 容器中收缩 */
        }
        .brand span {
            display: block;
            line-height: 1.1; /* 紧凑行高，适合两行显示 */
        }
        .brand::before {
            content: 'F';
            background: var(--accent-cyan);
            color: #000;
            width: 24px;
            height: 24px;
            min-width: 24px; /* 防止压缩 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 900;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 6px; /* 更加紧凑 */
        }

        /* 小屏幕适配 (< 380px) */
        @media (max-width: 380px) {
            html { font-size: 14px; } /* 缩小基准字体 */
            .brand span { display: none; } /* 隐藏文字只留 Logo */
            .header-right { gap: 4px; }
            .qso-count-badge { padding: 0 6px; }
            header { padding: 8px 10px; }
        }

        /* 输入框允许选择 */
        input, textarea {
            user-select: auto;
        }

        .theme-btn {
            background: transparent;
            border: 1px solid var(--border-color); /* 保持微妙边框 */
            color: var(--accent-cyan); /* 统一主题色 */
            width: 28px; /* 缩小尺寸 */
            height: 28px;
            border-radius: 6px; /* 稍微减小圆角 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            padding: 0;
        }
        .theme-btn svg {
            width: 16px;
            height: 16px;
        }
        .theme-btn:active { background: rgba(255,255,255,0.1); }

        .status-indicators {
            display: flex;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #555;
            transition: all 0.3s ease;
        }
        .status-dot.connected { background-color: var(--accent-green); box-shadow: 0 0 5px var(--accent-green); }
        .status-dot.error { background-color: #ff3333; box-shadow: 0 0 5px #ff3333; }

        /* 主可视区域 */
        .viz-container {
            grid-area: viz;
            position: relative;
            background: var(--viz-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            cursor: pointer; /* 提示可点击 */
            min-height: 0; /* 防止 grid item 溢出 */
            margin: 10px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .viz-info-container {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
            align-items: center;
        }

        #current-station-text {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 10;
            /* Override any defaults if needed, but viz-mode-badge class handles most */
        }

        .viz-mode-badge {
            padding: 4px 10px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            font-size: 0.75rem;
            /* pointer-events: none; Handled by container */
            opacity: 1;
            white-space: nowrap;
        }

        /* 实时字幕覆盖层 */
        .subtitle-overlay {
            position: absolute;
            bottom: 45px; /* 在 current-station-text 之上 */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            z-index: 20;
            pointer-events: none;
            animation: fadeIn 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .subtitle-overlay span {
            font-weight: bold;
            font-size: 1.1rem;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
        }

        /* 控制面板区域 */
        .controls-area {
            grid-area: controls;
            background: var(--panel-bg);
            border-top: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: auto;
            max-height: 50vh; /* 限制最大高度，给波形留空间 */
            overflow-y: auto;
            transition: background 0.5s, border-color 0.5s;
            margin: 0 10px 10px 10px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }

        /* 播放控制 */


        .control-btn-group {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: space-between; /* 在小屏上分散对齐，或 center */
            width: 100%;
        }

        /* 统一大按钮样式 - 调整为矩形 */
        .btn-rect-lg {
            height: 40px; /* 降低高度 (原48px) */
            flex: 1; /* 均匀分布 */
            min-width: 0;
            padding: 0;
            border-radius: 6px; /* 稍微减小圆角 */
            border: 1px solid var(--accent-magenta);
            background: rgba(255, 152, 0, 0.1);
            color: var(--accent-cyan);
            font-size: 1.1rem; /* 稍微调小图标 */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            box-shadow: none;
        }
        
        /* 播放按钮突出显示 */
        #btn-play {
            background: var(--accent-cyan);
            color: #000;
            border: none;
            flex: 2; /* 更宽 */
        }
        #btn-play:active { transform: scale(0.98); opacity: 0.9; }

        /* 录音按钮 */
        .btn-record {
            border-color: #d32f2f;
            color: #d32f2f;
            background: rgba(211, 47, 47, 0.1);
        }
        .btn-record.recording {
            background: #d32f2f;
            color: #fff;
            box-shadow: 0 0 10px #d32f2f;
            animation: none;
        }

        /* 顶部设置区域 */
        #settings-area {
            grid-area: settings;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 20px;
            max-height: 0; /* Use max-height for transition */
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            z-index: 99;
            margin: 0 10px;
            border-radius: 0 0 var(--radius-md) var(--radius-md);
            margin-top: -10px; /* 连接 Header */
            border-top: none;
        }
        #settings-area.open {
            max-height: 300px; /* Enough space for content */
            padding: 20px;
            margin-bottom: 10px;
        }
        
        /* 历史设备列表样式 */
        .device-history {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        #settings-area.open .device-history {
            opacity: 1;
            transform: translateY(0);
        }

        .device-tag {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        .device-tag:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-main);
        }
        .device-tag.active {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 243, 255, 0.1);
        }
        .device-del {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(0,0,0,0.3);
            font-size: 10px;
            line-height: 1;
            color: #aaa;
        }
        .device-del:hover {
            background: #ff3333;
            color: white;
        }
        .btn-rect-lg:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .btn-rect-lg.active { background: var(--accent-magenta); color: var(--bg-color); box-shadow: 0 0 15px var(--accent-magenta); }

        /* 录音按钮特殊样式覆盖 */
        .btn-record {
            border-color: #ff3333;
            color: #ff3333;
        }
        .btn-record.recording {
            background: rgba(255, 51, 51, 0.2);
            box-shadow: 0 0 15px #ff3333;
            animation: pulse 1.5s infinite;
        }
        .btn-record .icon {
            width: 14px;
            height: 14px;
            background-color: currentColor;
            border-radius: 50%; /* 录音图标为圆点 */
            transition: all 0.2s;
        }
        .btn-record.recording .icon {
            border-radius: 50%;
            transform: scale(0.8);
        }

        /* 音量条容器 */
        .vol-bar-container {
            display: flex;
            align-items: center;
            width: 100%;
            height: 48px;
            padding: 0 15px;
            box-sizing: border-box;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
        }

        .vol-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            margin-right: 15px;
            cursor: pointer;
        }
        
        .vol-track-wrapper {
            flex: 1;
            height: 48px; /* 增大触摸热区 */
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .vol-track {
            width: 100%;
            height: 6px; /* 加粗 */
            background: #333;
            border-radius: 3px;
            position: relative;
            overflow: visible;
        }

        .vol-fill {
            height: 100%;
            background: var(--accent-cyan);
            border-radius: 3px;
            width: 50%; /* 默认值 */
            position: relative;
            box-shadow: none;
            transition: width 0.1s linear;
        }

        /* 滑块头部圆点 */
        .vol-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-cyan);
            border-radius: 50%;
            position: absolute;
            right: -9px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            border: 2px solid #fff;
        }
        
        .vol-track-wrapper:active .vol-thumb {
            transform: translateY(-50%) scale(1.1);
        }

        .vol-value-text {
            width: 45px;
            text-align: right;
            font-size: 14px;
            color: var(--text-muted);
            font-family: monospace;
            margin-left: 15px;
        }

        /* 台站列表 */
        .station-panel {
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-md);
            padding: 15px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex: 1; /* 填充剩余空间 */
            min-height: 150px; /* 保证最小高度 */
            overflow: hidden;
            margin: 0 0px 0px 0px; /* 与 Controls 对齐 */
        }
        
        .station-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem; /* 稍微调小 */
            color: var(--text-muted);
        }

        .station-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 8px;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden; /* 防止横向滚动 */
            padding-right: 2px; /* 给滚动条留点位置 */
            padding-bottom: 50px; /* 底部留白给按钮 */
            position: relative;
        }




        .station-item {
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            font-size: 0.9rem; /* 调小列表字体 */
        }
        .station-item.active {
            background: rgba(0, 243, 255, 0.1);
            border-left-color: var(--accent-cyan);
        }
        .station-item:active { background: rgba(255,255,255,0.1); }
        
        .st-name { 
            font-weight: 500;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 设置面板 */
        .settings-panel {
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        .input-group {
            display: flex;
            gap: 10px;
        }
        .input-dark {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }
        .btn-small {
            padding: 0 15px;
            background: rgba(255,255,255,0.1);
            border: 1px solid var(--border-color);
            color: var(--text-main);
            border-radius: 8px;
            font-size: 0.9rem;
        }
        .btn-small:active { background: rgba(255,255,255,0.2); }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 51, 51, 0.4); }
            70% { box-shadow: 0 0 0 8px rgba(255, 51, 51, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 51, 51, 0); }
        }

        /* 滚动条美化 */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }

        /* 工具类 */
        .hidden { display: none !important; }
        .text-cyan { color: var(--accent-cyan); }
        
        /* 平板/桌面端适配 (Landscape & Large Screens) */
        @media (min-width: 768px), (orientation: landscape) and (min-height: 300px) and (min-width: 560px) {
            body {
                grid-template-columns: 1fr 340px; /* 固定右侧控制栏宽度 */
                grid-template-rows: auto auto 1fr;
                grid-template-areas: 
                    "header header"
                    "settings settings"
                    "viz controls";
            }

            .controls-area {
                height: 100%;
                max-height: none;
                border-top: none;
                border-left: 1px solid var(--border-color);
                padding-bottom: 20px;
                margin: 0 10px 10px 0; /* 调整 margin */
                border-radius: var(--radius-md);
            }

            .viz-container {
                height: auto; /* 自动填充 */
                margin: 0 10px 10px 10px; /* 调整 margin */
            }
            
            /* 在宽屏下增加台站列数 */
            .station-list {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* 更紧凑 */
            }
        }
        
        /* 超大屏幕适配 */
        @media (min-width: 1200px) {
            body {
                grid-template-columns: 1fr 400px; /* 更宽的控制栏 */
            }
            .viz-container {
                margin: 0 15px 15px 15px;
            }
            .controls-area {
                margin: 0 15px 15px 0;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: var(--panel-bg);
            width: 90%; max-width: 600px; max-height: 80vh;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: translateY(20px);
            transition: transform 0.3s;
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h3 { margin: 0; color: var(--text-main); font-size: 1.2rem; }
        .btn-icon { background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; padding: 0 5px; }
        .qso-list {
            flex: 1; overflow-y: auto; padding: 0;
        }
        .qso-item {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .qso-item:last-child { border-bottom: none; }
        .qso-info { display: flex; flex-direction: column; gap: 4px; }
        .qso-call { font-weight: bold; color: var(--text-main); font-size: 1.1rem; display: flex; align-items: center; }
        .qso-meta { font-size: 0.85rem; color: var(--text-muted); display: flex; gap: 10px; }
        .qso-freq { color: var(--accent-green); font-family: monospace; }
        .qso-mode { background: rgba(255, 152, 0, 0.2); color: var(--accent-cyan); padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; font-weight: bold; margin-left: 8px; }
        .qso-time { font-size: 0.8rem; color: #666; }

        .qso-count-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: var(--accent-cyan); /* 统一主题色 */
            font-weight: bold;
            font-size: 0.8rem;
            background: transparent;
            padding: 0 8px;
            height: 28px; /* 统一高度 */
            border-radius: 6px; /* 统一圆角 */
            border: 1px solid var(--border-color); /* 统一边框 */
            cursor: pointer; /* 可点击 */
            min-width: 40px; /* 保证最小宽度 */
            transition: all 0.2s ease;
        }
        .qso-count-badge:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.1);
        }
        .qso-count-badge svg {
            width: 14px;
            height: 14px;
            fill: none; /* 空心 */
            stroke: currentColor; /* 跟随文字颜色 */
            stroke-width: 2;
        }
    </style>
</head>
<body>

    <!-- 顶部功能区：品牌、操作按钮、连接状态 -->
    <header>
        <div class="brand"><span>FMO CONTROLLER</span></div>
        <div class="header-right">
            <div class="qso-count-badge" id="qso-badge" title="已通联 QSO 数量">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <span id="qso-count-value">0</span>
            </div>
            <button id="btn-settings-toggle" class="theme-btn" title="设置">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
            </button>
            <button id="btn-qso" class="theme-btn" title="QSO 日志">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
            </button>

            <button id="btn-theme" class="theme-btn" title="切换主题">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2"/><path d="M12 21v2"/><path d="M4.22 4.22l1.42 1.42"/><path d="M18.36 18.36l1.42 1.42"/><path d="M1 12h2"/><path d="M21 12h2"/><path d="M4.22 19.78l1.42-1.42"/><path d="M18.36 5.64l1.42-1.42"/></svg>
            </button>
            <div class="status-indicators">
                <div id="led-ws" class="status-dot" title="控制连接"></div>
                <div id="led-audio" class="status-dot" title="音频连接"></div>
            </div>
        </div>
    </header>

    <!-- 设置面板：输入 IP、历史设备与发现设备 -->
    <div id="settings-area">
        <div class="input-group">
            <input type="text" id="inp-host" class="input-dark" placeholder="设备 IP 地址" value="">
            <button id="btn-connect" class="btn-small text-cyan">CONNECT</button>
        </div>

        <div id="device-history" class="device-history"></div>
        <div id="discovered-list" class="device-history" style="margin-top: 10px; border-top: 1px dashed #333; padding-top: 10px; display: none;"></div>
    </div>

    <!-- 可视化区域：频谱/字幕/模式标记 -->
    <div class="viz-container" id="viz-area">
        <canvas id="viz-canvas"></canvas>
        <div class="viz-mode-badge" id="current-station-text" style="display: none;"></div>
        
        <!-- 字幕覆盖层：语音识别显示 -->
        <div id="subtitle-overlay" class="subtitle-overlay" style="display: none;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                <line x1="12" y1="19" x2="12" y2="23"/>
                <line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
            <span id="subtitle-text"></span>
        </div>

        <div class="viz-info-container">
            <div class="viz-mode-badge" id="viz-mode-text">SPECTRUM</div>
        </div>
    </div>

    <!-- 控制区：播放、录音、台站切换、音量 -->
    <div class="controls-area">
        <!-- 播放器控制：包含播放/录音/上下台切换 -->
        <div class="control-btn-group">
            <button id="btn-play" class="btn-rect-lg">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
            </button>
            <!-- 录音按钮：中间图标为圆点 -->
            <button id="btn-record" class="btn-rect-lg btn-record" title="录音">
                <div class="icon"></div>
            </button>

            <button id="btn-prev" class="btn-rect-lg" title="上一台">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
            </button>
            <button id="btn-next" class="btn-rect-lg" title="下一台">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
            </button>
        </div>

        <!-- 音量控制条 -->
        <div class="vol-bar-container" id="vol-container">
            <div class="vol-icon" id="vol-mute-btn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                </svg>
            </div>
            <div class="vol-track-wrapper" id="vol-track-wrapper">
                <div class="vol-track">
                    <div class="vol-fill" id="vol-fill">
                        <div class="vol-thumb"></div>
                    </div>
                </div>
            </div>
            <div class="vol-value-text" id="vol-value-text">100%</div>
        </div>

        <!-- 台站列表 -->
        <div class="station-panel">
            <div class="station-header">
                <span>STATIONS</span>
                <span id="st-count">0/0</span>
            </div>
            <div id="st-list" class="station-list">
                <div class="station-item" style="grid-column: 1 / -1; justify-content: center; align-items: center; color: #666;">等待连接...点击顶部设置按钮设置IP</div>
            </div>

        </div>


    </div>

    <!-- QSO Log Modal -->
    <div id="qso-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>QSO LOGS</h3>
                <button id="btn-qso-close" class="btn-icon">×</button>
            </div>
            <div id="qso-list" class="qso-list">
                <!-- QSO items will be injected here -->
                <div style="padding: 20px; text-align: center; color: #666;">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Credits Modal -->
    <div id="credits-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>致谢与贡献</h3>
                <button id="btn-credits-close" class="btn-icon">×</button>
            </div>
            <div style="padding: 30px 20px; text-align: center; overflow-y: auto;">
                <div class="brand" style="justify-content: center; font-size: 1.5rem; margin-bottom: 20px; color: var(--accent-cyan);">
                    <span>FMO CONTROLLER</span>
                </div>
                <div id="credits-version" data-version="1.0" style="margin-bottom: 18px; color: var(--text-muted); font-size: 0.9rem;">v1.0</div>
                
                <div style="margin-bottom: 25px;">
                    <h4 style="color: var(--accent-magenta); margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; display: inline-block;">核心贡献者</h4>
                    <div style="color: var(--text-main); font-size: 1.1rem; margin-bottom: 5px;">BG5ESN、BG6RGQ、BG5EIT、BG4LLK</div>
                    <div style="color: var(--text-muted); font-size: 0.9rem;">Lead Developer</div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: var(--accent-green); margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; display: inline-block;">特别鸣谢</h4>
                    <div style="color: var(--text-main); margin-bottom: 5px;">FMO Team</div>

                </div>
                
                <div style="margin-top: 30px; font-size: 0.8rem; color: #666;">
                    Thank you for using FMO!
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 核心类定义区域 ---
        
        /** 音量条控制器 */
        class VolumeSlider {
            constructor(container, player) {
                this.container = container;
                this.player = player;
                this.trackWrapper = container.querySelector('#vol-track-wrapper');
                this.fill = container.querySelector('#vol-fill');
                this.text = container.querySelector('#vol-value-text');
                this.muteBtn = container.querySelector('#vol-mute-btn');
                
                this.isDragging = false;
                this.value = 1.0; // 0.0 - 1.0
                
                this.initEvents();
                this.updateUI(this.value);
            }

            initEvents() {
                // 点击或拖动处理
                const updateFromEvent = (e) => {
                    const rect = this.trackWrapper.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    let percent = (clientX - rect.left) / rect.width;
                    percent = Math.max(0, Math.min(1, percent));
                    
                    // 0-200% 音量映射 (0.0 - 2.0)
                    const volumeValue = percent * 2.0;
                    this.setVolume(volumeValue);
                };

                // 鼠标事件
                this.trackWrapper.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    updateFromEvent(e);
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });

                const onMove = (e) => {
                    if (this.isDragging) {
                        updateFromEvent(e);
                        e.preventDefault();
                    }
                };

                const onUp = () => {
                    this.isDragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                // 触摸事件
                this.trackWrapper.addEventListener('touchstart', (e) => {
                    this.isDragging = true;
                    updateFromEvent(e);
                    document.addEventListener('touchmove', onTouchMove, { passive: false });
                    document.addEventListener('touchend', onTouchEnd);
                });

                const onTouchMove = (e) => {
                    if (this.isDragging) {
                        updateFromEvent(e);
                        e.preventDefault();
                    }
                };

                const onTouchEnd = () => {
                    this.isDragging = false;
                    document.removeEventListener('touchmove', onTouchMove);
                    document.removeEventListener('touchend', onTouchEnd);
                };

                // 静音切换
                this.muteBtn.addEventListener('click', () => {
                    if (this.value > 0) {
                        this.lastValue = this.value;
                        this.setVolume(0);
                    } else {
                        this.setVolume(this.lastValue || 1.0);
                    }
                    // 震动
                    if (navigator.vibrate) navigator.vibrate(10);
                });
            }

            setVolume(val) {
                this.value = val;
                this.player.setVolume(val); // 假设 player 支持 0-2.0
                this.updateUI(val);
            }

            updateUI(val) {
                // 显示百分比 (0-200%)
                const displayPercent = Math.round(val * 100);
                // 进度条宽度 (映射 0-2.0 到 0-100%)
                const fillWidth = Math.min(100, (val / 2.0) * 100);
                
                this.fill.style.width = `${fillWidth}%`;
                this.text.textContent = `${displayPercent}%`;
                
                // 更新图标状态
                if (val === 0) {
                    this.muteBtn.style.opacity = '0.5';
                    this.muteBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`;
                } else {
                    this.muteBtn.style.opacity = '1';
                    this.muteBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`;
                }
            }
        }

        /** 基础事件发射器 */
        class EventEmitter {
            constructor() { this.events = {}; }
            on(event, listener) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(listener);
            }
            emit(event, ...args) {
                if (this.events[event]) this.events[event].forEach(fn => fn(...args));
            }
        }

        /** WebSocket 控制客户端 */
        class ControlClient extends EventEmitter {
            constructor() {
                super();
                // 配置常量 - 提取以提高可维护性
                this.CONFIG = {
                    FETCH_PAGE_SIZE: 20,
                    AUTO_REFRESH_INTERVAL: 30000,
                    RECONNECT_DELAY: 3000,
                    POST_SWITCH_DELAY: 3000
                };

                this.ws = null;
                this.connected = false;
                this.reconnectTimer = null;
                this.autoUpdateTimer = null; // 自动更新定时器
                this.host = '';
                this.stationList = []; // 存储所有已加载的台站
                this.currentStationId = null; // 当前台站ID
                
                // 全量加载状态管理
                this.fetchingAll = false;
                this.tempStationList = [];
                this.fetchStart = 0;
                this.fetchPageSize = this.CONFIG.FETCH_PAGE_SIZE; // 每次获取限制
            }

            connect(host) {
                // 重置加载状态，确保每次连接都能重新获取
                this.fetchingAll = false;
                this.tempStationList = [];
                this.fetchStart = 0;

                this.host = host;
                if (this.ws) {
                    // 关闭旧连接前清除定时器
                    this.stopAutoRefresh();
                    this.ws.close();
                    this.ws = null;
                }

                try {
                    this.ws = new WebSocket(`ws://${this.host}/ws`);
                    
                    this.ws.onopen = () => {
                        this.connected = true;
                        this.emit('status', true);
                        this.stationList = []; // 重置列表
                        // 连接后自动获取所有列表和当前台站
                        this.fetchList(); // 初始加载
                        this.send('station', 'getCurrent');

                        // 开启30秒自动更新
                        this.startAutoRefresh();
                    };

                    this.ws.onclose = () => {
                        this.connected = false;
                        this.emit('status', false);
                        
                        // 清除自动更新
                        this.stopAutoRefresh();

                        // 3秒后重连
                        clearTimeout(this.reconnectTimer);
                        this.reconnectTimer = setTimeout(() => this.connect(this.host), this.CONFIG.RECONNECT_DELAY);
                    };

                    this.ws.onerror = (e) => {
                        console.error('WS Error:', e);
                        this.connected = false;
                        this.emit('status', false);
                    };

                    this.ws.onmessage = (e) => {
                        try {
                            const msg = JSON.parse(e.data);
                            this.handleMessage(msg);
                        } catch (err) {
                            console.error('Parse Error:', err);
                        }
                    };

                } catch (e) {
                    console.error('Connection Failed:', e);
                    this.emit('status', false);
                }
            }

            send(type, subType, data = {}) {
                if (!this.connected || !this.ws) return;
                this.ws.send(JSON.stringify({ type, subType, data }));
            }

            handleMessage(msg) {
                // 路由不同类型的消息
                if (msg.type === 'station') {
                    switch (msg.subType) {
                        case 'getListResponse':
                            const newList = msg.data.list || [];
                            const start = msg.data.start;

                            // 如果正在进行全量加载流程
                            if (this.fetchingAll) {
                                // 校验 start (如果服务器返回了 start)
                                if (start !== undefined && start !== this.fetchStart) {
                                    console.warn(`Fetch order mismatch: expected ${this.fetchStart}, got ${start}`);
                                    this.fetchingAll = false;
                                    return;
                                }

                                this.tempStationList = this.tempStationList.concat(newList);
                                
                                // 检查是否还有更多数据
                                // 如果返回的数量少于请求的数量，说明是最后一页
                                if (newList.length < this.fetchPageSize) {
                                    // 加载完成
                                    console.log(`Fetch complete. Total: ${this.tempStationList.length}`);
                                    this.stationList = this.tempStationList;
                                    this.fetchingAll = false;
                                    this.tempStationList = [];
                                    
                                    // 过滤空值
                                    this.stationList = this.stationList.filter(i => i);
                                    this.emit('stationList', this.stationList);
                                } else {
                                    // 继续获取下一页
                                    this.fetchStart += this.fetchPageSize;
                                    this.send('station', 'getListRange', { start: this.fetchStart, count: this.fetchPageSize });
                                }
                            } else {
                                // 非全量加载模式（兼容旧逻辑或单次更新）
                                if ((start === 0 || start === undefined) && newList.length > 0) {
                                    this.stationList = newList;
                                    this.emit('stationList', this.stationList);
                                }
                            }
                            break;
                        case 'getCurrentResponse':
                            if (msg.data && msg.data.uid) {
                                this.currentStationId = msg.data.uid;
                            }
                            this.emit('stationCurrent', msg.data);
                            break;
                        case 'setCurrentResponse':
                            // 操作结果，可加 Toast
                            break;
                    }
                } else if (msg.type === 'qso') {
                    this.emit('qsoMessage', msg);
                }
            }

            // 快捷指令
            setStation(uid) { 
                // 乐观更新：立即更新本地状态，解决连续点击失效问题
                this.currentStationId = uid;
                
                this.send('station', 'setCurrent', { uid }); 
                // Delay before fetching current station to ensure server state update
                setTimeout(() => this.send('station', 'getCurrent'), this.CONFIG.POST_SWITCH_DELAY);
            }

            nextStation() { 
                this.send('station', 'next');
                // Delay before fetching current station to ensure server state update
                setTimeout(() => this.send('station', 'getCurrent'), this.CONFIG.POST_SWITCH_DELAY);
            }

            prevStation() { 
                this.send('station', 'prev');
                // Delay before fetching current station to ensure server state update
                setTimeout(() => this.send('station', 'getCurrent'), this.CONFIG.POST_SWITCH_DELAY);
            }
            
            // 全量获取逻辑 (递归/分片获取)
            fetchList() {
                if (this.fetchingAll) return; // 避免重复触发
                
                this.fetchingAll = true;
                this.tempStationList = [];
                this.fetchStart = 0;
                
                // 发起第一次请求
                this.send('station', 'getListRange', { start: 0, count: this.fetchPageSize });
            }

            startAutoRefresh() {
                this.stopAutoRefresh();
                this.autoUpdateTimer = setInterval(() => {
                    if (this.connected) {
                        this.fetchList();
                    }
                }, this.CONFIG.AUTO_REFRESH_INTERVAL); // 30秒间隔
            }

            stopAutoRefresh() {
                if (this.autoUpdateTimer) {
                    clearInterval(this.autoUpdateTimer);
                    this.autoUpdateTimer = null;
                }
            }
            
            // QSO 指令
            getQsoList(page = 0, pageSize = 20) {
                this.send('qso', 'getList', { page, pageSize });
            }
        }

        /** 音频播放器 (PCM 流处理) */
        class AudioPlayer extends EventEmitter {
            constructor() {
                super();
                this.audioCtx = null;
                this.ws = null;
                this.connected = false;
                this.analyser = null;
                this.gainNode = null;
                // 音频处理链节点
                this.hpfNode = null;
                this.lpfNode = null;
                this.eqLow = null;
                this.eqMid = null;
                this.eqHigh = null;
                this.compressor = null;
                
                // 缓冲调度相关
                this.chunkQueue = [];
                this.scheduledEndTime = 0;
                this.started = false;
                this.buffering = true;
                
                // 音频参数
                this.sampleRate = 8000;
                this.targetLead = 0.5; // 目标领先时间(s)

                // 录音相关
                this.recording = false;
                this.recordedChunks = [];
            }

            async ensureAudioContext() {
                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioCtx.createAnalyser();
                    this.analyser.fftSize = 1024; // 降低分辨率以提高性能 (原 2048)
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    this.gainNode = this.audioCtx.createGain();
                    this.gainNode.gain.value = 1.0;

                    // 音频处理链优化 (参考 API 文档)
                    // 1. 300Hz HPF: 去除亚音频 (CTCSS/DCS) 和低频噪声
                    this.hpfNode = this.audioCtx.createBiquadFilter();
                    this.hpfNode.type = 'highpass';
                    this.hpfNode.frequency.value = 300;

                    // 2. 3000Hz LPF: 模拟电台带宽，去除高频刺耳噪声
                    this.lpfNode = this.audioCtx.createBiquadFilter();
                    this.lpfNode.type = 'lowpass';
                    this.lpfNode.frequency.value = 3000;
                    this.lpfNode.Q.value = 0.5;

                    // 3. EQ 低频 (LowShelf 180Hz +0.5dB)
                    this.eqLow = this.audioCtx.createBiquadFilter();
                    this.eqLow.type = 'lowshelf';
                    this.eqLow.frequency.value = 180;
                    this.eqLow.gain.value = 0.5;

                    // 4. EQ 中频 (Peaking 1400Hz +1.0dB Q=0.8) - 增强人声清晰度
                    this.eqMid = this.audioCtx.createBiquadFilter();
                    this.eqMid.type = 'peaking';
                    this.eqMid.frequency.value = 1400;
                    this.eqMid.Q.value = 0.8;
                    this.eqMid.gain.value = 1.0;

                    // 5. EQ 高频 (HighShelf 2600Hz 0dB)
                    this.eqHigh = this.audioCtx.createBiquadFilter();
                    this.eqHigh.type = 'highshelf';
                    this.eqHigh.frequency.value = 2600;
                    this.eqHigh.gain.value = 0;

                    // 6. 动态压缩器: 平衡音量，防止爆音
                    this.compressor = this.audioCtx.createDynamicsCompressor();
                    this.compressor.threshold.value = -22;
                    this.compressor.knee.value = 24;
                    this.compressor.ratio.value = 2;

                    // 连线: Source -> Gain -> HPF -> LPF -> EQ(L/M/H) -> Comp -> Analyser -> Dest
                    this.gainNode.connect(this.hpfNode);
                    this.hpfNode.connect(this.lpfNode);
                    this.lpfNode.connect(this.eqLow);
                    this.eqLow.connect(this.eqMid);
                    this.eqMid.connect(this.eqHigh);
                    this.eqHigh.connect(this.compressor);
                    this.compressor.connect(this.analyser);
                    this.analyser.connect(this.audioCtx.destination);
                }
                if (this.audioCtx.state === 'suspended') {
                    try {
                        await this.audioCtx.resume();
                    } catch (e) {
                        console.warn('Auto-resume failed, waiting for user gesture.');
                    }
                }
            }

            unlock() {
                if (this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume().then(() => {
                        console.log('AudioContext resumed via user interaction');
                    }).catch(e => console.error(e));
                }
            }

            connect(host) {
                if (this.connected) return;
                this.ensureAudioContext();
                
                // 重置状态
                this.chunkQueue = [];
                this.scheduledEndTime = this.audioCtx.currentTime;
                this.started = false;
                this.buffering = true;

                try {
                    this.ws = new WebSocket(`ws://${host}/audio`);
                    this.ws.binaryType = 'arraybuffer';

                    this.ws.onopen = () => {
                        this.connected = true;
                        this.emit('status', true);
                    };

                    this.ws.onclose = () => {
                        this.connected = false;
                        this.emit('status', false);
                    };

                    this.ws.onmessage = (e) => {
                        if (e.data instanceof ArrayBuffer) {
                            this.handlePCM(e.data);
                        }
                    };
                } catch (e) {
                    console.error('Audio Connect Failed:', e);
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.connected = false;
                this.emit('status', false);
            }

            handlePCM(buffer) {
                // 录音收集
                if (this.recording) {
                    this.recordedChunks.push(buffer.slice(0));
                }

                // PCM16 -> Float32
                const int16 = new Int16Array(buffer);
                const float32 = new Float32Array(int16.length);
                const scale = 1.0 / 32768;
                for (let i = 0; i < int16.length; i++) {
                    float32[i] = int16[i] * scale;
                }
                
                this.chunkQueue.push(float32);
                this.schedule();
            }

            startRecording() {
                this.recording = true;
                this.recordedChunks = [];
            }

            stopRecording() {
                this.recording = false;
                const blob = this.exportWAV();
                this.recordedChunks = [];
                return blob;
            }

            exportWAV() {
                if (this.recordedChunks.length === 0) return null;
                // 计算总长度
                const totalLen = this.recordedChunks.reduce((acc, c) => acc + c.byteLength, 0);
                const buffer = new Uint8Array(totalLen);
                let offset = 0;
                for (const chunk of this.recordedChunks) {
                    buffer.set(new Uint8Array(chunk), offset);
                    offset += chunk.byteLength;
                }
                
                // 创建 WAV 头
                const wavHeader = this.createWavHeader(totalLen, 1, this.sampleRate, 16);
                return new Blob([wavHeader, buffer], { type: 'audio/wav' });
            }

            createWavHeader(dataLength, numChannels, sampleRate, bitsPerSample) {
                const header = new ArrayBuffer(44);
                const view = new DataView(header);
                
                // RIFF chunk descriptor
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataLength, true);
                this.writeString(view, 8, 'WAVE');
                
                // fmt sub-chunk
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
                view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true); // ByteRate
                view.setUint16(32, numChannels * bitsPerSample / 8, true); // BlockAlign
                view.setUint16(34, bitsPerSample, true);
                
                // data sub-chunk
                this.writeString(view, 36, 'data');
                view.setUint32(40, dataLength, true);
                
                return header;
            }
            
            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            schedule() {
                if (!this.audioCtx) return;
                
                // 如果处于挂起状态，不进行调度，避免错误日志刷屏
                if (this.audioCtx.state === 'suspended') return;

                const now = this.audioCtx.currentTime;
                if (this.scheduledEndTime < now) this.scheduledEndTime = now;

                // 简单的缓冲策略
                if (this.buffering) {
                    // 积攒约 0.1s 数据再开始 (原为 0.5s，降低延迟)
                    const totalSamples = this.chunkQueue.reduce((acc, c) => acc + c.length, 0);
                    if (totalSamples / this.sampleRate > 0.1) {
                        this.buffering = false;
                        this.started = true;
                    } else {
                        return;
                    }
                }

                // 延迟控制/追赶逻辑
                // 如果计划时间落后当前时间太多（欠载），重置为当前时间
                if (this.scheduledEndTime < now) {
                    this.scheduledEndTime = now + 0.01; // 给一点小缓冲
                }
                
                // 如果计划时间超前当前时间太多（积压），进行丢包处理以减少延迟
                const latency = this.scheduledEndTime - now;
                if (latency > 0.3) { // 允许最大 300ms 延迟
                    // 丢弃队列头部的包，直到延迟在此范围内
                    // 注意：这会导致音频跳跃，但在实时通信中低延迟优先
                    console.log(`Latency too high (${latency.toFixed(3)}s), skipping packets...`);
                    // 简单粗暴：清空队列，重置时间
                    this.chunkQueue = [];
                    this.scheduledEndTime = now + 0.05;
                    return;
                }

                // 调度所有队列中的块
                while (this.chunkQueue.length) {
                    const chunk = this.chunkQueue.shift();
                    const buffer = this.audioCtx.createBuffer(1, chunk.length, this.sampleRate);
                    buffer.copyToChannel(chunk, 0);

                    const source = this.audioCtx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.gainNode);
                    source.start(this.scheduledEndTime);

                    this.scheduledEndTime += chunk.length / this.sampleRate;
                }
            }

            setVolume(val) {
                if (this.gainNode) this.gainNode.gain.value = val;
            }
        }

        /** 可视化引擎 */
        class Visualizer {
            constructor(canvas, analyser) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.analyser = analyser;
                this.freqData = null;
                this.mode = 0; 
                this.modes = ['SPECTRUM', 'MIRROR', 'WAVEFORM', 'OSCILLOSCOPE', 'RADIAL', 'PARTICLES'];
                this.running = false;
                
                // 粒子系统状态 (用于 PARTICLES 模式)
                this.particles = [];
                for(let i=0; i<100; i++) {
                    this.particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3,
                        color: this.colorTheme
                    });
                }

                // 缓存主题颜色
                this.colorTheme = '#00f3ff';
                this.colorSecondary = '#ff00ff';
                this.updateThemeColors();

                this.resize();
                
                // 使用 ResizeObserver 监听容器大小变化，解决布局变动导致的变形问题
                this.resizeObserver = new ResizeObserver(() => this.resize());
                this.resizeObserver.observe(this.canvas);
            }

            updateThemeColors() {
                const styles = getComputedStyle(document.body);
                this.colorTheme = styles.getPropertyValue('--accent-cyan').trim() || '#00f3ff';
                this.colorSecondary = styles.getPropertyValue('--accent-magenta').trim() || '#ff00ff';
            }

            resize() {
                this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
                this.canvas.height = this.canvas.clientHeight * window.devicePixelRatio;
            }

            setAnalyser(analyser) { this.analyser = analyser; this.freqData = null; }

            switchMode() {
                this.mode = (this.mode + 1) % this.modes.length;
                return this.modes[this.mode];
            }

            start() {
                if (this.running) return;
                this.running = true;
                this.loop();
            }

            loop() {
                if (!this.running) return;
                requestAnimationFrame(() => this.loop());
                
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // 使用缓存的主题颜色
                const colorTheme = this.colorTheme;
                const colorSecondary = this.colorSecondary;

                // 清空画布
                this.ctx.clearRect(0, 0, w, h);

                if (!this.analyser) return;

                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = (this.freqData && this.freqData.length === bufferLength)
                    ? this.freqData
                    : (this.freqData = new Uint8Array(bufferLength));
                const modeName = this.modes[this.mode];

                // 通用粒子绘制设置
                // 性能优化：移动端减少阴影渲染
                this.ctx.shadowBlur = 0; 
                this.ctx.shadowColor = colorTheme;
                this.ctx.fillStyle = colorTheme;
                this.ctx.strokeStyle = colorTheme;

                if (modeName === 'SPECTRUM') { 
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    const displayW = this.canvas.clientWidth || (w / window.devicePixelRatio);
                    const barCount = Math.max(24, Math.min(36, Math.floor(displayW / 12)));
                    const step = Math.max(1, Math.floor(bufferLength / barCount));
                    const colWidth = w / barCount;
                    const groundY = h * 0.85; // 地平线位置
                    
                    // 初始化峰值数组
                    if (!this.peaks || this.peaks.length !== barCount) {
                        this.peaks = new Array(barCount).fill(0);
                    }

                    for(let i = 0; i < barCount; i++) {
                        const value = dataArray[i * step] || 0;
                        
                        // 增强：增加高度敏感度
                        const barHeight = (value / 255) * groundY * 0.95; 
                        const x = i * colWidth + colWidth/2;
                        
                        // 1. 绘制主体粒子柱 (向上)
                        // 增强：增加粒子密度和大小
                        const particleCount = Math.floor(barHeight / 14); 
                        for (let j = 0; j < particleCount; j++) {
                            const y = groundY - (j * 14 + 10);
                            const ratio = j / particleCount; 
                            
                            this.ctx.beginPath();
                            // 增强：粒子更大，随高度变化
                            const size = 3 + ratio * 3.5; 
                            this.ctx.arc(x, y, size, 0, Math.PI * 2);
                            
                            if (j === particleCount - 1) {
                                this.ctx.fillStyle = '#ffffff';
                                this.ctx.shadowBlur = 8;
                                this.ctx.shadowColor = '#ffffff';
                            } else {
                                this.ctx.fillStyle = i % 2 === 0 ? colorTheme : colorSecondary;
                                this.ctx.shadowBlur = 0;
                            }
                            
                            this.ctx.globalAlpha = ratio * 0.7 + 0.3;
                            this.ctx.fill();
                        }
                        this.ctx.shadowBlur = 0; // Reset

                        // 2. 绘制倒影粒子 (向下)
                        const reflectCount = Math.floor(particleCount / 3);
                        for (let j = 0; j < reflectCount; j++) {
                            const y = groundY + (j * 14 + 10);
                            // 超出屏幕不绘制
                            if (y > h) break;
                            
                            const ratio = 1 - (j / reflectCount); // 越远越淡
                            
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                            this.ctx.fillStyle = i % 2 === 0 ? colorTheme : colorSecondary;
                            this.ctx.globalAlpha = ratio * 0.15;
                            this.ctx.fill();
                        }
                        
                        // 3. 绘制掉落峰值
                        if (barHeight > this.peaks[i]) {
                            this.peaks[i] = barHeight;
                        } else {
                            this.peaks[i] -= 2; 
                        }
                        
                        if (this.peaks[i] > 0) {
                            const peakY = groundY - this.peaks[i] - 12;
                            this.ctx.beginPath();
                            this.ctx.arc(x, peakY, 3, 0, Math.PI * 2);
                            this.ctx.fillStyle = colorSecondary;
                            this.ctx.globalAlpha = 1.0;
                            this.ctx.fill();
                        }
                    }
                    
                    // 绘制地平线光晕
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, groundY);
                    this.ctx.lineTo(w, groundY);
                    this.ctx.strokeStyle = colorTheme;
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.4;
                    this.ctx.stroke();
                    
                    this.ctx.globalAlpha = 1.0;
                }
                else if (modeName === 'MIRROR') {
                    this.analyser.getByteFrequencyData(dataArray);
                    const step = Math.ceil(bufferLength / 64);
                    const cx = w / 2;
                    
                    for(let i = 0; i < bufferLength; i += step) {
                        const value = dataArray[i];
                        const barHeight = (value / 255) * (h / 2);
                        const offset = (i / bufferLength) * (w / 2);
                        
                        // 绘制对称粒子
                        const particleCount = Math.floor(barHeight / 8);
                        for (let j = 0; j < particleCount; j++) {
                            const dy = j * 10;
                            const size = 2.5;
                            const alpha = (j / particleCount) * 0.8 + 0.2;
                            
                            this.ctx.globalAlpha = alpha;
                            
                            // 右侧
                            this.ctx.beginPath();
                            this.ctx.arc(cx + offset, (h/2) - dy, size, 0, Math.PI*2); // 上
                            this.ctx.fill();
                            this.ctx.beginPath();
                            this.ctx.arc(cx + offset, (h/2) + dy, size, 0, Math.PI*2); // 下
                            this.ctx.fill();

                            // 左侧
                            this.ctx.beginPath();
                            this.ctx.arc(cx - offset, (h/2) - dy, size, 0, Math.PI*2);
                            this.ctx.fill();
                            this.ctx.beginPath();
                            this.ctx.arc(cx - offset, (h/2) + dy, size, 0, Math.PI*2);
                            this.ctx.fill();
                        }
                    }
                    this.ctx.globalAlpha = 1.0;
                }
                else if (modeName === 'WAVEFORM') {
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.ctx.lineWidth = 0; // 不画线
                    
                    const sliceWidth = w * 1.0 / bufferLength;
                    let x = 0;
                    
                    // 仅每隔几个点绘制一个发光粒子，形成离散波形
                    const pointStep = 4; 
                    for(let i = 0; i < bufferLength; i += pointStep) {
                        const v = dataArray[i] / 128.0;
                        const y = v * h/2; // 居中
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                        this.ctx.fillStyle = colorTheme;
                        // 动态透明度模拟闪烁
                        this.ctx.globalAlpha = Math.random() * 0.5 + 0.5;
                        this.ctx.fill();
                        
                        x += sliceWidth * pointStep;
                    }
                    this.ctx.globalAlpha = 1.0;
                }
                else if (modeName === 'OSCILLOSCOPE') {
                    this.analyser.getByteTimeDomainData(dataArray);
                    // 示波器：高速运动的粒子轨迹
                    const sliceWidth = w * 1.0 / bufferLength;
                    let x = 0;
                    
                    for(let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * h/2;
                        
                        if (i % 2 === 0) { // 减少绘制点数优化性能
                            this.ctx.beginPath();
                            this.ctx.rect(x, y, 2, 2); // 使用方块增加科技感
                            this.ctx.fillStyle = colorTheme;
                            this.ctx.fill();
                        }
                        x += sliceWidth;
                    }
                    
                    // 网格背景 (点阵)
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.shadowBlur = 0;
                    for (let gx = 0; gx < w; gx += 50) {
                        for (let gy = 0; gy < h; gy += 50) {
                            this.ctx.fillRect(gx, gy, 1, 1);
                        }
                    }
                }
                else if (modeName === 'RADIAL') { 
                    this.analyser.getByteFrequencyData(dataArray);
                    const cx = w / 2;
                    const cy = h / 2;
                    const radius = Math.min(w, h) / 5; // 稍微缩小基础半径
                    
                    // 整体旋转效果
                    this.ctx.save();
                    this.ctx.translate(cx, cy);
                    this.ctx.rotate(Date.now() * 0.0005); // 缓慢自转
                    
                    // 镜像绘制两圈
                    const count = 40; 
                    const step = Math.floor(bufferLength / count);
                    
                    for(let i = 0; i < count; i++) { 
                        const value = dataArray[i * step];
                        const angle = (i / count) * Math.PI * 2;
                        
                        // 1. 内圈 (Theme Color)
                        const r1 = radius + (value / 255) * 40;
                        const x1 = Math.cos(angle) * r1;
                        const y1 = Math.sin(angle) * r1;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                        this.ctx.fillStyle = colorTheme;
                        this.ctx.fill();
                        
                        // 2. 外圈 (Secondary Color) - 增加偏移
                        const v2 = dataArray[Math.min((i * step + 5), bufferLength-1)];
                        const r2 = radius * 1.8 + (v2 / 255) * 60;
                        const x2 = Math.cos(angle) * r2;
                        const y2 = Math.sin(angle) * r2;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x2, y2, 2, 0, Math.PI * 2);
                        this.ctx.fillStyle = colorSecondary;
                        this.ctx.fill();
                        
                        // 3. 能量连线 (当音量较大时)
                        if (value > 128) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x1, y1);
                            this.ctx.lineTo(x2, y2);
                            this.ctx.strokeStyle = colorTheme;
                            this.ctx.lineWidth = 1;
                            this.ctx.globalAlpha = 0.3;
                            this.ctx.stroke();
                            this.ctx.globalAlpha = 1.0;
                        }
                    }
                    
                    // 核心呼吸效果
                    const bass = dataArray[5] / 255.0;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius * (0.8 + bass * 0.4), 0, Math.PI * 2);
                    this.ctx.fillStyle = colorTheme;
                    this.ctx.globalAlpha = 0.1 + bass * 0.2;
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                else if (modeName === 'PARTICLES') {
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // 计算能量分区
                    let bass = 0, mid = 0, treble = 0;
                    for(let i=0; i<bufferLength; i++) {
                        if(i < 10) bass += dataArray[i];
                        else if(i < 100) mid += dataArray[i];
                        else treble += dataArray[i];
                    }
                    bass = bass / 10;
                    mid = mid / 90;
                    treble = treble / (bufferLength - 100);
                    
                    const cx = w / 2;
                    const cy = h / 2;
                    
                    // 粒子漩涡效果
                    this.particles.forEach((p, index) => {
                        // 1. 运动逻辑
                        const dx = p.x - cx;
                        const dy = p.y - cy;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // 速度随低频能量变化
                        const spiralSpeed = 0.01 + (bass / 1000);
                        const outSpeed = 1 + (mid / 20) + (dist * 0.01);
                        
                        const newAngle = angle + spiralSpeed;
                        const newDist = dist + outSpeed;
                        
                        p.x = cx + Math.cos(newAngle) * newDist;
                        p.y = cy + Math.sin(newAngle) * newDist;
                        
                        // 2. 边界重生
                        const maxDist = Math.max(w, h) * 0.7;
                        if(dist > maxDist) {
                            p.x = cx + (Math.random() - 0.5) * 10;
                            p.y = cy + (Math.random() - 0.5) * 10;
                            p.color = Math.random() > 0.5 ? colorTheme : colorSecondary;
                        }
                        
                        // 3. 绘制
                        this.ctx.beginPath();
                        // 大小随高频颤动
                        const pSize = p.size * (0.5 + (treble / 100)); 
                        this.ctx.arc(p.x, p.y, pSize, 0, Math.PI * 2);
                        this.ctx.fillStyle = p.color;
                        
                        // 透明度随距离增加
                        const alpha = Math.min(1, dist / (maxDist/2));
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fill();
                        
                        // 4. 动态连线 (当低频强劲时)
                        if (bass > 180) {
                            // 只与附近的点连线，优化性能
                            for(let j=index+1; j<Math.min(index+10, this.particles.length); j++) {
                                const p2 = this.particles[j];
                                const d2 = Math.hypot(p.x - p2.x, p.y - p2.y);
                                if (d2 < 50) {
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(p.x, p.y);
                                    this.ctx.lineTo(p2.x, p2.y);
                                    this.ctx.strokeStyle = p.color;
                                    this.ctx.lineWidth = 0.5;
                                    this.ctx.globalAlpha = 0.3 * (bass/255);
                                    this.ctx.stroke();
                                }
                            }
                        }
                    });
                    this.ctx.globalAlpha = 1.0;
                }
                
                // Reset shadow for next frame performance
                this.ctx.shadowBlur = 0;
            }
        }

        /** 发现管理器 (mDNS) */
        class DiscoveryManager extends EventEmitter {
            constructor() {
                super();
                this.services = new Map();
                this.isScanning = false;
                this.serviceType = '_http._tcp.local.'; 
                this.listEl = document.getElementById('discovered-list');
                
                // 监听 deviceready 事件自动开始扫描
                document.addEventListener('deviceready', () => this.startScan(), false);
            }

            startScan() {
                if (this.isScanning) return;
                
                const performScan = () => {
                    if (this.isScanning) return; 
                    
                    if (window.cordova && cordova.plugins && cordova.plugins.zeroconf) {
                        console.log('Starting mDNS scan...');
                        this.isScanning = true;
                        this.services.clear();
                        this.updateUI();
                        
                        cordova.plugins.zeroconf.watch(this.serviceType, 'local.', 
                            (result) => {
                                const { action, service } = result;
                                if (action === 'resolved') {
                                    if (service.ipv4Addresses && service.ipv4Addresses.length > 0) {
                                        service.ip = service.ipv4Addresses[0];
                                        this.services.set(service.name, service);
                                        this.updateUI();
                                    }
                                } else if (action === 'removed') {
                                    this.services.delete(service.name);
                                    this.updateUI();
                                }
                            },
                            (err) => {
                                console.error('ZeroConf Watch Error:', err);
                                this.isScanning = false;
                            }
                        );
                    } else {
                        console.warn('ZeroConf plugin not available');
                    }
                };

                // Request NEARBY_WIFI_DEVICES permission for Android 13+ (API 33)
                if (window.cordova && cordova.plugins && cordova.plugins.permissions) {
                    const permissions = cordova.plugins.permissions;
                    const nearbyPerm = 'android.permission.NEARBY_WIFI_DEVICES';

                    permissions.checkPermission(nearbyPerm, (status) => {
                        if (status.hasPermission) {
                            performScan();
                        } else {
                            permissions.requestPermission(nearbyPerm, 
                                (s) => {
                                    // 无论权限请求成功与否，都尝试进行扫描
                                    // 1. 如果是 Android 13+ 且用户授权，扫描正常工作
                                    // 2. 如果是旧版本 Android，该权限可能不适用，直接扫描
                                    performScan();
                                },
                                (err) => {
                                    console.warn('Permission request failed:', err);
                                    performScan();
                                }
                            );
                        }
                    }, (err) => {
                        console.warn('Permission check failed:', err);
                        performScan();
                    });
                } else {
                    performScan();
                }
            }

            stopScan() {
                if (this.isScanning && window.cordova && cordova.plugins && cordova.plugins.zeroconf) {
                    cordova.plugins.zeroconf.unwatch(this.serviceType, 'local.');
                }
                this.isScanning = false;
            }

            updateUI() {
                if (!this.listEl) return;
                
                // 只有当有设备时才显示容器，或者正在扫描且没有任何历史记录时可以提示
                if (this.services.size === 0) {
                    this.listEl.style.display = 'none';
                    return;
                }
                
                this.listEl.style.display = 'flex';
                this.listEl.innerHTML = '';
                
                // 添加标题
                const header = document.createElement('div');
                header.style.width = '100%';
                header.style.fontSize = '0.8rem';
                header.style.color = '#888';
                header.style.marginBottom = '5px';
                header.textContent = '发现设备 (Nearby)';
                this.listEl.appendChild(header);

                this.services.forEach(service => {
                    const tag = document.createElement('div');
                    tag.className = 'device-tag';
                    tag.style.borderColor = 'var(--accent-magenta)';
                    
                    const name = service.name || service.ip;
                    const ip = service.ip;
                    
                    tag.innerHTML = `
                        <span style="color:var(--accent-magenta)">●</span> ${name} <small style="color:#666">(${ip})</small>
                    `;
                    
                    tag.onclick = () => {
                        document.getElementById('inp-host').value = ip;
                        // Trigger connect
                        document.getElementById('btn-connect').click();
                    };
                    
                    this.listEl.appendChild(tag);
                });
            }
        }

        /** 设备历史管理 */
        class DeviceManager {
            constructor() {
                this.devices = [];
                this.storageKey = 'fmo_saved_devices';
                this.load();
            }

            load() {
                try {
                    const saved = localStorage.getItem(this.storageKey);
                    this.devices = saved ? JSON.parse(saved) : [];
                } catch (e) {
                    this.devices = [];
                }
            }

            save() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.devices));
                this.render();
            }

            add(ip) {
                if (!ip) return;
                // 移除已存在的（为了置顶）
                this.devices = this.devices.filter(d => d !== ip);
                // 添加到头部
                this.devices.unshift(ip);
                // 限制数量
                if (this.devices.length > 5) this.devices.pop();
                this.save();
            }

            remove(ip, e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                this.devices = this.devices.filter(d => d !== ip);
                this.save();
            }

            render() {
                const container = document.getElementById('device-history');
                if (!container) return;
                container.innerHTML = '';
                
                const currentIp = document.getElementById('inp-host').value;

                this.devices.forEach(ip => {
                    const tag = document.createElement('div');
                    tag.className = 'device-tag';
                    if (currentIp === ip) tag.classList.add('active');
                    
                    tag.innerHTML = `
                        ${ip}
                        <span class="device-del" title="删除">✕</span>
                    `;
                    
                    tag.onclick = () => {
                        document.getElementById('inp-host').value = ip;
                        this.render(); // 更新高亮
                        // 触发连接
                        document.getElementById('btn-connect').click();
                    };
                    
                    const delBtn = tag.querySelector('.device-del');
                    delBtn.onclick = (e) => this.remove(ip, e);
                    
                    container.appendChild(tag);
                });
            }
        }

        /** QSO 日志管理器 */
        class QsoManager {
            constructor(client) {
                this.client = client;
                this.modal = document.getElementById('qso-modal');
                this.listEl = document.getElementById('qso-list');
                this.btn = document.getElementById('btn-qso');
                this.btnClose = document.getElementById('btn-qso-close');
                this.countEl = document.getElementById('qso-count-value');
                this.badge = document.getElementById('qso-badge');
                
                this.page = 0;
                this.pageSize = 20; // Default page size
                this.isLoading = false;
                this.refreshTimer = null; // Auto refresh timer

                if (this.btn && this.modal) {
                    this.initEvents();
                }
            }

            initEvents() {
                // Open Modal
                const openModal = () => this.show();
                this.btn.addEventListener('click', openModal);
                // 交互优化：点击星星直接打开 QSO 日志
                if (this.badge) this.badge.addEventListener('click', openModal);

                // Close Modal
                this.btnClose.addEventListener('click', () => {
                    this.hide();
                });
                
                // Close on backdrop click
                this.modal.addEventListener('click', (e) => {
                    if (e.target === this.modal) this.hide();
                });

                // Handle WS messages
                this.client.on('qsoMessage', (msg) => {
                    if (msg.subType === 'getListResponse') {
                        // 更新数量统计
                        if (msg.data.total !== undefined) {
                            this.updateCount(msg.data.total);
                        } else if (msg.data.list) {
                            this.updateCount(msg.data.list.length);
                        }
                        this.renderList(msg.data.list || []);
                    }
                });

                // 连接状态变化处理
                this.client.on('status', (connected) => {
                    if (connected) {
                        this.fetchData(); // 立即获取一次
                        this.startAutoRefresh(); // 开启自动刷新
                    } else {
                        this.stopAutoRefresh(); // 停止刷新
                    }
                });
            }

            startAutoRefresh() {
                this.stopAutoRefresh();
                // 每15秒刷新一次，确保星星数量（QSO计数）实时更新
                this.refreshTimer = setInterval(() => {
                    this.fetchData();
                }, 15000);
            }

            stopAutoRefresh() {
                if (this.refreshTimer) {
                    clearInterval(this.refreshTimer);
                    this.refreshTimer = null;
                }
            }

            updateCount(count) {
                if (this.countEl) {
                    this.countEl.textContent = count;
                }
            }

            show() {
                this.modal.classList.add('show');
                this.fetchData(true);
            }

            hide() {
                this.modal.classList.remove('show');
            }

            fetchData(showLoading = false) {
                if (showLoading) {
                    this.listEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">Loading...</div>';
                }
                this.client.getQsoList(this.page, this.pageSize);
            }

            formatDate(ts) {
                if (!ts) return '-';
                const d = new Date(ts * 1000);
                const pad = (n) => String(n).padStart(2, '0');
                return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
            }

            renderList(list) {
                if (!list || list.length === 0) {
                    this.listEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No QSO logs found.</div>';
                    return;
                }

                this.listEl.innerHTML = list.map(item => {
                    const call = item.toCallsign || 'UNKNOWN';
                    const grid = item.grid || '-';
                    const time = this.formatDate(item.timestamp);
                    // item.freqHz unit is uncertain, assuming Hz and converting to MHz
                    const freq = item.freqHz ? (item.freqHz / 1000000).toFixed(4) + ' MHz' : ''; 
                    
                    return `
                    <div class="qso-item">
                        <div class="qso-info">
                            <div class="qso-call">
                                ${call}
                                <span class="qso-mode">${grid}</span>
                            </div>
                            <div class="qso-meta">
                                ${freq ? `<span class="qso-freq">${freq}</span>` : ''}
                                <span class="qso-time">${time}</span>
                            </div>
                        </div>
                    </div>
                    `;
                }).join('');
            }
        }

        /** 事件订阅客户端 (EventsService) */
        class EventsClient {
            constructor() {
                this.ws = null;
                this.host = '';
                this.connected = false;
                this.reconnectTimer = null;
                this.retryMs = 1000;
                this.listeners = new Set();
                this.subtitleEl = document.getElementById('subtitle-overlay');
                this.subtitleText = document.getElementById('subtitle-text');
                this.speakingTimeout = null;
            }

            connect(host) {
                this.host = host;
                if (this.ws) return;

                try {
                    this.ws = new WebSocket(`ws://${host}/events`);
                    
                    this.ws.onopen = () => {
                        this.connected = true;
                        this.retryMs = 1000;
                        console.log('Events connected');
                    };

                    this.ws.onmessage = (e) => {
                        try {
                            const msg = JSON.parse(e.data);
                            this.handleMessage(msg);
                        } catch (err) {
                            console.error('Events parse error:', err);
                        }
                    };

                    this.ws.onclose = () => {
                        this.connected = false;
                        this.ws = null;
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = () => {
                        this.ws = null; // Let onclose handle it
                    };

                } catch (e) {
                    console.error('Events connect failed:', e);
                    this.scheduleReconnect();
                }
            }

            disconnect() {
                if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
                if (this.ws) {
                    this.ws.onclose = null; // Prevent reconnect
                    this.ws.close();
                    this.ws = null;
                }
                this.connected = false;
            }

            scheduleReconnect() {
                if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
                this.reconnectTimer = setTimeout(() => {
                    this.retryMs = 1000; // 保持 1秒 重试，不增加时间
                    this.connect(this.host);
                }, this.retryMs);
            }

            handleMessage(msg) {
                // 处理 QSO 发言人事件
                if (msg.type === 'qso' && msg.subType === 'callsign' && msg.data) {
                    const { callsign, isSpeaking } = msg.data;
                    this.updateSubtitle(callsign, isSpeaking);
                }
            }

            updateSubtitle(callsign, isSpeaking) {
                if (!this.subtitleEl || !this.subtitleText) return;

                if (isSpeaking) {
                    this.subtitleText.textContent = callsign;
                    this.subtitleEl.style.display = 'flex';
                    
                    // 去除自动隐藏的时间判断，只要 isSpeaking 为 true 就一直显示
                    if (this.speakingTimeout) clearTimeout(this.speakingTimeout);
                } else {
                    // 停止发言时立即隐藏
                    this.subtitleEl.style.display = 'none';
                    if (this.speakingTimeout) clearTimeout(this.speakingTimeout);
                }
            }
        }

        // --- 应用逻辑 ---
        const ctrl = new ControlClient();
        const player = new AudioPlayer();
        const events = new EventsClient(); // 实例化
        const viz = new Visualizer(document.getElementById('viz-canvas'), null);
        const deviceMgr = new DeviceManager();
        const discoveryMgr = new DiscoveryManager();
        const qsoMgr = new QsoManager(ctrl);
        
        const ui = {
            ledWs: document.getElementById('led-ws'),
            ledAudio: document.getElementById('led-audio'),
            btnTheme: document.getElementById('btn-theme'),
            btnSettingsToggle: document.getElementById('btn-settings-toggle'),
            settingsArea: document.getElementById('settings-area'),
            btnPlay: document.getElementById('btn-play'),
            btnRecord: document.getElementById('btn-record'),
            vizArea: document.getElementById('viz-area'),
            vizModeText: document.getElementById('viz-mode-text'),
            currentStationText: document.getElementById('current-station-text'),
            stCount: document.getElementById('st-count'),
            stList: document.getElementById('st-list'),
            btnPrev: document.getElementById('btn-prev'),
            btnNext: document.getElementById('btn-next'),
            inpHost: document.getElementById('inp-host'),
            btnConnect: document.getElementById('btn-connect'),
        };

        let currentStationId = null;
        
        // 设备检测与适配
        const checkDevice = () => {
            // 简单判断：屏幕宽度大于 768px 视为桌面端/平板
            if (window.innerWidth >= 768) {
                document.documentElement.classList.add('device-desktop');
            } else {
                document.documentElement.classList.remove('device-desktop');
            }
        };
        // 初始化检测
        checkDevice();
        // 监听窗口大小变化
        window.addEventListener('resize', checkDevice);

        // 0. 主题切换
        // 扩展主题列表：包含新增的4款主题
        const themes = ['', 'theme-matrix', 'theme-ocean', 'theme-sunset', 'theme-light', 'theme-pink', 'theme-purple', 'theme-red', 'theme-black'];
        let currentThemeIndex = 0;
        
        ui.btnTheme.addEventListener('click', () => {
            if (themes[currentThemeIndex]) {
                document.body.classList.remove(themes[currentThemeIndex]);
            }
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            if (themes[currentThemeIndex]) {
                document.body.classList.add(themes[currentThemeIndex]);
            }
            // Update visualizer colors
            viz.updateThemeColors();
        });

        // 0.1 设置开关
        ui.btnSettingsToggle.addEventListener('click', () => {
            ui.settingsArea.classList.toggle('open');
        });



        // 1. 连接逻辑
        ui.btnConnect.addEventListener('click', () => {
            const host = ui.inpHost.value.trim();
            if (!host) return;
            ctrl.connect(host);
            player.connect(host);
            events.connect(host);
            viz.start();
            deviceMgr.add(host);
        });

        ctrl.on('status', (connected) => {
            ui.ledWs.className = `status-dot ${connected ? 'connected' : 'error'}`;
            if (connected) {
                ui.btnConnect.textContent = '已连接';
                ui.btnConnect.style.color = 'var(--accent-green)';
            } else {
                ui.btnConnect.textContent = 'CONNECT';
                ui.btnConnect.style.color = 'var(--accent-cyan)';
            }
        });

        player.on('status', (connected) => {
            ui.ledAudio.className = `status-dot ${connected ? 'connected' : 'error'}`;
            // 音频连接后，将分析节点交给可视化引擎
            if (connected && player.analyser) {
                viz.setAnalyser(player.analyser);
            }
        });

        // 2. 播放控制
        ui.btnPlay.addEventListener('click', () => {
            const host = ui.inpHost.value.trim();
            if (!player.connected) {
                player.connect(host);
            } else {
                // 仅作为重连或断开开关
                player.disconnect();
            }
        });
        
        // 监听音频连接状态改变按钮样式
        player.on('status', (connected) => {
            if (connected) {
                ui.btnPlay.classList.add('active');
                ui.btnPlay.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
            } else {
                ui.btnPlay.classList.remove('active');
                ui.btnPlay.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
            }
        });

        // 音量条初始化
        const volContainer = document.getElementById('vol-container');
        const volSlider = new VolumeSlider(volContainer, player);

        // 3. 可视化切换
        ui.vizArea.addEventListener('click', () => {
            const modeName = viz.switchMode();
            ui.vizModeText.textContent = modeName;
        });

        // 5. 录音控制：开始/停止录音，导出为 WAV
        ui.btnRecord.addEventListener('click', () => {
            if (!player.recording) {
                // 开始录音（需要音频已连接）
                if (!player.connected) {
                    alert('请先连接音频！');
                    return;
                }
                player.startRecording();
                ui.btnRecord.classList.add('recording');
            } else {
                // 停止录音并下载（文件名带时间戳）
                ui.btnRecord.classList.remove('recording');
                const blob = player.stopRecording();
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    // 文件名：fmo_rec_时间戳.wav
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    a.download = `fmo_rec_${timestamp}.wav`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                } else {
                    alert('录音时长太短或无数据');
                }
            }
        });

        // 4. 台站列表逻辑
        ctrl.on('stationList', (list) => {
            ui.stCount.textContent = `${list.length} STATIONS`;
            ui.stList.innerHTML = '';
            
            if (list.length === 0) {
                ui.stList.innerHTML = '<div class="station-item" style="grid-column: 1 / -1; justify-content: center; align-items: center; color: #666;">暂无台站</div>';
                return;
            }

            list.forEach(st => {
                const el = document.createElement('div');
                el.className = 'station-item';
                el.dataset.uid = st.uid;
                if (st.uid == currentStationId) el.classList.add('active');
                
                el.innerHTML = `
                    <div class="st-name">${st.name || 'Station ' + st.uid}</div>
                `;
                el.onclick = () => {
                    ctrl.setStation(st.uid);
                    // 乐观更新 UI
                    document.querySelectorAll('.station-item').forEach(i => i.classList.remove('active'));
                    el.classList.add('active');
                    currentStationId = st.uid;
                    
                    // Update viz text immediately
                    if (ui.currentStationText) {
                        ui.currentStationText.textContent = st.name || 'Station ' + st.uid;
                        ui.currentStationText.style.display = 'block';
                    }
                };
                ui.stList.appendChild(el);
            });


        });

        ctrl.on('stationCurrent', (data) => {
            currentStationId = data.uid;
            
            // Update current station text in viz area
            if (ui.currentStationText) {
                if (data && data.name) {
                    ui.currentStationText.textContent = data.name;
                    ui.currentStationText.style.display = 'block';
                } else {
                    ui.currentStationText.style.display = 'none';
                }
            }

            // 高亮当前
            const items = document.querySelectorAll('.station-item');
            items.forEach(el => {
                if (el.dataset.uid == currentStationId) el.classList.add('active');
                else el.classList.remove('active');
            });
        });

        ui.btnPrev.addEventListener('click', () => ctrl.prevStation());
        ui.btnNext.addEventListener('click', () => ctrl.nextStation());

        // 5. 全局点击唤醒音频上下文（解决自动连接时的 AudioContext 策略限制）
        const unlockAudio = () => {
            if (player) player.unlock();
        };
        document.addEventListener('click', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);
        document.addEventListener('keydown', unlockAudio);

        // 6. 启动
        // 初始化设备历史列表
        deviceMgr.render();

        // 自动连接
        setTimeout(() => {
            const lastHost = deviceMgr.devices.length > 0 ? deviceMgr.devices[0] : 'fmo.local';
            if (ui.inpHost) {
                ui.inpHost.value = lastHost;
                // 触发连接按钮点击事件以复用连接逻辑
                if (ui.btnConnect) {
                    ui.btnConnect.click();
                }
            }
        }, 1000);

        // 7. 彩蛋逻辑
        let eggClicks = 0;
        let eggTimer = null;
        const statusIndicators = document.querySelector('.status-indicators');
        const creditsModal = document.getElementById('credits-modal');
        const btnCreditsClose = document.getElementById('btn-credits-close');

        if (statusIndicators && creditsModal && btnCreditsClose) {
            statusIndicators.addEventListener('click', (e) => {
                if (eggClicks === 0) {
                    // 第一次点击，启动计时器
                    eggTimer = setTimeout(() => {
                        eggClicks = 0;
                        // console.log('Easter egg reset');
                    }, 10000); // 10秒内
                }
                
                eggClicks++;
                
                if (eggClicks >= 10) {
                    // 触发彩蛋
                    if (eggTimer) clearTimeout(eggTimer);
                    eggClicks = 0;
                    creditsModal.classList.add('show');
                }
            });

            btnCreditsClose.addEventListener('click', () => {
                creditsModal.classList.remove('show');
            });
            
            // 点击遮罩关闭
            creditsModal.addEventListener('click', (e) => {
                if (e.target === creditsModal) {
                    creditsModal.classList.remove('show');
                }
            });
        }

    </script>

</body>
</html>
